---
import { Icon } from "astro-icon/components";
import { siteConfig } from "../../config";

const tocDepth = siteConfig.toc.depth;
const useJapaneseBadge = siteConfig.toc.useJapaneseBadge;
---

<div
	class="floating-toc-wrapper"
	data-depth={tocDepth}
	data-japanese-badge={useJapaneseBadge}
>
	<button
		id="floating-toc-btn"
		class="floating-toc-btn btn-card"
		aria-label="Table of Contents"
	>
		<svg
			class="progress-ring"
			width="100%"
			height="100%"
			viewBox="0 0 100 100"
		>
			<circle
				class="progress-ring-circle"
				cx="50"
				cy="50"
				r="40"
				fill="transparent"></circle>
		</svg>
		<div class="btn-icon">
			<Icon
				name="material-symbols:format-list-bulleted-rounded"
				class="text-2xl"
			/>
		</div>
	</button>
	<div id="floating-toc-panel" class="floating-toc-panel">
		<div class="floating-toc-panel-content" id="floating-toc-content"></div>
	</div>
</div>

<style>
	.floating-toc-wrapper {
		position: fixed;
		right: 6rem;
		bottom: 15rem;
		z-index: 50;
		pointer-events: auto;
		transform: translateX(5rem);
		display: none;
		transition:
			opacity 0.3s ease,
			transform 0.3s ease;
	}

	.floating-toc-wrapper.active-toc {
		display: block;
	}

	.floating-toc-btn {
		width: 3.75rem;
		height: 3.75rem;
		border-radius: 1rem;
		display: flex;
		align-items: center;
		justify-content: center;
		color: var(--primary);
		position: relative;
		background: var(--card-bg);
	}

	.floating-toc-btn.active {
		background: var(--btn-card-bg-active);
	}

	.progress-ring {
		position: absolute;
		top: 0;
		left: 0;
		transform: rotate(-90deg);
		pointer-events: none;
		z-index: 0;
	}

	.progress-ring-circle {
		stroke: var(--primary);
		stroke-width: 5;
		stroke-dasharray: 251.2;
		stroke-dashoffset: 251.2;
		transition: stroke-dashoffset 0.1s linear;
		stroke-linecap: round;
	}

	.btn-icon {
		z-index: 1;
		position: relative;
	}

	.floating-toc-panel {
		position: absolute;
		bottom: 4.5rem;
		right: 0;
		width: 18rem;
		max-height: 60vh;
		background: var(--card-bg);
		border: 1px solid var(--line-color);
		border-radius: 1rem;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
		overflow: hidden;
		opacity: 0;
		visibility: hidden;
		transform: translateY(10px) scale(0.95);
		transition: all 0.2s ease;
		pointer-events: none;
	}

	.floating-toc-panel.show {
		opacity: 1;
		visibility: visible;
		transform: translateY(0) scale(1);
		pointer-events: auto;
	}

	.floating-toc-panel-content {
		padding: 0.75rem;
		max-height: 60vh;
		overflow-y: auto;
		overflow-x: hidden;
	}

	.floating-toc-panel-content::-webkit-scrollbar {
		width: 4px;
	}

	.floating-toc-panel-content::-webkit-scrollbar-track {
		background: transparent;
	}

	.floating-toc-panel-content::-webkit-scrollbar-thumb {
		background: var(--line-color);
		border-radius: 2px;
	}

	@media (max-width: 1560px) {
		.floating-toc-btn {
			box-shadow:
				0 0 0 1px var(--btn-regular-bg),
				0 0 1em var(--btn-regular-bg);
		}
	}

	@media (max-width: 768px) {
		.floating-toc-wrapper {
			transform: none;
			right: 2rem;
			bottom: 6rem;
			opacity: 0.6;
		}

		.floating-toc-wrapper:active,
		.floating-toc-wrapper.active {
			opacity: 1;
		}

		.floating-toc-panel {
			width: 85vw;
			max-width: 20rem;
			right: 0;
			bottom: 4.5rem;
		}
	}

	:global(.floating-toc-item) {
		display: flex;
		align-items: center;
		padding: 0.5rem;
		color: var(--text-secondary);
		text-decoration: none;
		font-size: 0.9rem;
		line-height: 1.5;
		border-radius: 0.5rem;
		transition: all 0.2s;
	}

	:global(.floating-toc-item:hover) {
		background-color: var(--btn-regular-bg);
		color: var(--primary);
	}

	:global(.floating-toc-item.active) {
		background-color: var(--btn-card-bg-active);
		color: var(--primary);
		font-weight: 500;
	}

	:global(.floating-toc-badge) {
		display: inline-flex;
		align-items: center;
		justify-content: center;
		width: 1.25rem;
		height: 1.25rem;
		background: var(--btn-regular-bg);
		color: var(--primary);
		border-radius: 0.25rem;
		font-size: 0.75rem;
		font-weight: bold;
		margin-right: 0.5rem;
		flex-shrink: 0;
	}

	:global(.floating-toc-dot) {
		width: 0.5rem;
		height: 0.5rem;
		background: var(--line-divider);
		border-radius: 50%;
		margin-right: 0.75rem;
		margin-left: 0.375rem;
		flex-shrink: 0;
	}

	:global(.floating-toc-dot-small) {
		width: 0.35rem;
		height: 0.35rem;
		background: var(--line-divider);
		border-radius: 50%;
		margin-right: 0.75rem;
		margin-left: 0.45rem;
		flex-shrink: 0;
	}

	:global(.floating-toc-item.active .floating-toc-dot),
	:global(.floating-toc-item.active .floating-toc-dot-small) {
		background: var(--primary);
	}

	:global(.floating-toc-text) {
		overflow: hidden;
		text-overflow: ellipsis;
		white-space: nowrap;
	}
</style>

<script>
	class FloatingTOC {
		private btn: HTMLElement | null;
		private panel: HTMLElement | null;
		private content: HTMLElement | null;
		private wrapper: HTMLElement | null;
		private isOpen = false;
		private headings: HTMLElement[] = [];
		private containerObserver: MutationObserver | null = null;
		
		// 添加 AbortController 用于清理事件监听
		private abortController: AbortController;

		constructor() {
			this.btn = document.getElementById("floating-toc-btn");
			this.panel = document.getElementById("floating-toc-panel");
			this.content = document.getElementById("floating-toc-content");
			this.wrapper = document.querySelector(".floating-toc-wrapper");
			this.abortController = new AbortController();

			if (!this.btn || !this.panel || !this.content || !this.wrapper) {
				console.warn('FloatingTOC: Required elements not found');
				return;
			}

			this.init();
		}

		private init() {
			// 使用 AbortController 的信号来添加事件监听
			const signal = this.abortController.signal;
			
			window.addEventListener("scroll", () => {
				this.updateProgress();
				this.updateActiveHeading();
			}, { 
				passive: true,
				signal 
			});

			window.addEventListener("resize", () => {
				this.updateActiveHeading();
			}, { 
				passive: true,
				signal 
			});

			// 使用防抖优化滚动性能
			let scrollTimeout: number;
			window.addEventListener("scroll", () => {
				if (scrollTimeout) {
					cancelAnimationFrame(scrollTimeout);
				}
				scrollTimeout = requestAnimationFrame(() => {
					this.updateProgress();
					this.updateActiveHeading();
				});
			}, { 
				passive: true,
				signal 
			});

			this.bindEvents();
			this.generateTOC();
			this.observeDocument();
			this.updateProgress();
		}

		private observeDocument() {
			// 断开已有的观察器
			if (this.containerObserver) {
				this.containerObserver.disconnect();
			}

			// 监听整个文档的变化
			this.containerObserver = new MutationObserver((mutations) => {
				// 检查是否有标题相关的变化
				const hasHeadingChanges = mutations.some(mutation => {
					return Array.from(mutation.addedNodes).some(node => {
						if (node.nodeType === Node.ELEMENT_NODE) {
							const element = node as Element;
							return element.matches?.('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]') ||
								   element.querySelector?.('h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]');
						}
						return false;
					});
				});

				if (hasHeadingChanges || this.headings.length === 0) {
					// 使用防抖避免频繁生成
					clearTimeout((this as any).generateTimeout);
					(this as any).generateTimeout = setTimeout(() => {
						this.generateTOC();
					}, 100);
				}
			});

			this.containerObserver.observe(document.body, {
				childList: true,
				subtree: true
			});
		}

		private hide() {
			this.wrapper?.classList.remove("active-toc");
			this.close();
		}

		private updateProgress() {
			if (!this.btn) return;

			const scrollTop = window.scrollY || document.documentElement.scrollTop;
			const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;
			const scrollPercent = docHeight > 0 ? scrollTop / docHeight : 0;

			const circle = this.btn.querySelector(
				".progress-ring-circle"
			) as SVGCircleElement;
			if (circle) {
				const radius = circle.r.baseVal.value;
				const circumference = radius * 2 * Math.PI;
				const offset = Math.max(
					0,
					Math.min(
						circumference,
						circumference - scrollPercent * circumference
					)
				);
				circle.style.strokeDashoffset = offset.toString();
			}
		}

		private updateActiveHeading() {
			if (!this.content || this.headings.length === 0) return;
			
			const scrollY = window.scrollY;
			const offsetTop = 150;

			let activeIndex = -1;
			for (let i = this.headings.length - 1; i >= 0; i--) {
				const heading = this.headings[i];
				if (heading && heading.isConnected) { // 检查元素是否还在 DOM 中
					const headingTop = heading.getBoundingClientRect().top + scrollY;
					if (headingTop <= scrollY + offsetTop) {
						activeIndex = i;
						break;
					}
				}
			}

			const links = Array.from(
				this.content.querySelectorAll(".floating-toc-item")
			);
			
			links.forEach((link, index) => {
				if (index === activeIndex) {
					link.classList.add("active");
				} else {
					link.classList.remove("active");
				}
			});
		}

		private generateTOC() {
			const container = document.querySelector(
				"#post-container, article, main, .content, .post-content, .prose, .markdown-content, .custom-md"
			) || document.body;

			const allHeadings = container.querySelectorAll(
				"h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"
			);

			if (allHeadings.length === 0) {
				this.hide();
				this.headings = [];
				return;
			}

			this.wrapper?.classList.add("active-toc");
			this.headings = [];

			const maxLevel = parseInt(this.wrapper?.dataset.depth || "3");
			const useJapaneseBadge = this.wrapper?.dataset.japaneseBadge === "true";

			const japaneseKatakana = [
				"ア", "イ", "ウ", "エ", "オ", "カ", "キ", "ク", "ケ", "コ",
				"サ", "シ", "ス", "セ", "ソ", "タ", "チ", "ツ", "テ", "ト",
				"ナ", "ニ", "ヌ", "ネ", "ノ", "ハ", "ヒ", "フ", "ヘ", "ホ",
			];

			let minLevel = 6;
			allHeadings.forEach((h) => {
				const level = parseInt(h.tagName[1]);
				if (level < minLevel) minLevel = level;
			});

			let html = "";
			let h1Count = 0;
			
			allHeadings.forEach((heading) => {
				const level = parseInt(heading.tagName[1]);

				if (level >= minLevel + maxLevel) return;

				this.headings.push(heading as HTMLElement);

				const indent = (level - minLevel) * 1;
				let badge = "";

				if (level === minLevel) {
					h1Count++;
					const badgeText = useJapaneseBadge && h1Count - 1 < japaneseKatakana.length
						? japaneseKatakana[h1Count - 1]
						: h1Count.toString();
					badge = `<span class="floating-toc-badge">${badgeText}</span>`;
				} else if (level === minLevel + 1) {
					badge = '<span class="floating-toc-dot"></span>';
				} else {
					badge = '<span class="floating-toc-dot-small"></span>';
				}

				const text = (heading.textContent || "").replace(/#+\s*$/, "");
				html += `<a href="#${heading.id}" class="floating-toc-item" style="padding-left: ${0.5 + indent}rem" data-level="${level - minLevel}">${badge}<span class="floating-toc-text">${text}</span></a>`;
			});

			if (this.content) {
				this.content.innerHTML = html;
			}

			this.updateActiveHeading();
		}

		private bindEvents() {
			const signal = this.abortController.signal;
			
			this.btn?.addEventListener("click", (e) => {
				e.stopPropagation();
				this.toggle();
			}, { signal });

			document.addEventListener("click", (e) => {
				if (this.isOpen && !this.wrapper?.contains(e.target as Node)) {
					this.close();
				}
			}, { signal });

			this.content?.addEventListener("click", (e) => {
				const link = (e.target as HTMLElement).closest("a");
				if (link) {
					e.preventDefault();
					const id = link.getAttribute("href")?.slice(1);
					if (id) {
						const element = document.getElementById(id);
						if (element) {
							const top = element.getBoundingClientRect().top + window.scrollY - 80;
							window.scrollTo({ top, behavior: "smooth" });
							
							setTimeout(() => {
								this.updateActiveHeading();
							}, 300);
							
							this.close();
						}
					}
				}
			}, { signal });

			document.addEventListener("keydown", (e) => {
				if (e.key === "Escape" && this.isOpen) this.close();
			}, { signal });
		}

		private toggle() {
			this.isOpen ? this.close() : this.open();
		}

		private open() {
			this.isOpen = true;
			this.panel?.classList.add("show");
			this.btn?.classList.add("active");
			this.wrapper?.classList.add("active");
			this.updateActiveHeading();
		}

		private close() {
			this.isOpen = false;
			this.panel?.classList.remove("show");
			this.btn?.classList.remove("active");
			this.wrapper?.classList.remove("active");
		}

		// 添加清理方法
		public destroy() {
			// 中止所有事件监听
			this.abortController.abort();
			
			// 断开 MutationObserver
			if (this.containerObserver) {
				this.containerObserver.disconnect();
				this.containerObserver = null;
			}
			
			// 清理引用
			this.btn = null;
			this.panel = null;
			this.content = null;
			this.wrapper = null;
			this.headings = [];
			
			// 清理定时器
			clearTimeout((this as any).generateTimeout);
		}
	}

	// 使用单例模式管理实例
	let instance: FloatingTOC | null = null;

	function initTOC() {
		// 销毁旧实例
		if (instance) {
			instance.destroy();
			instance = null;
		}
		
		// 创建新实例
		instance = new FloatingTOC();
	}

	// 页面加载时初始化
	document.addEventListener("DOMContentLoaded", initTOC);
	
	// 页面切换时重新初始化
	document.addEventListener("swup:page:view", initTOC);
	
	// 页面卸载时清理（可选，用于 SPA）
	window.addEventListener("beforeunload", () => {
		if (instance) {
			instance.destroy();
			instance = null;
		}
	});
</script>
